import { createFilter } from '@rollup/pluginutils';
import MarkdownIt from 'markdown-it';
import { parseDOM, DomUtils } from 'htmlparser2';
import { Element, Text } from 'domhandler';
import { transformSync } from '@babel/core';
import frontMatter from 'front-matter';
import { isObject, toArray } from '@antfu/utils';
import path from 'path';
import { cwd } from 'process';
import fg from 'fast-glob';

function resolveOptions(useOptions) {
  const defaultOptions = {
    markdownItOptions: {},
    markdownItSetup: () => {
    },
    wrapperClasses: "vite-plugin-react-markdown",
    wrapperComponentName: "ViteReactMarkdown",
    markdownItUses: [],
    wrapperComponentPath: void 0,
    wrapperComponent: void 0,
    include: null,
    exclude: null
  };
  return { ...defaultOptions, ...useOptions };
}

const attribs = Object.entries(
  {
    class: "className",
    tabindex: "tabIndex"
  }
);
function transformAttribs(elementAttribs) {
  if (elementAttribs) {
    attribs.forEach((attrib) => {
      const [name, replaceName] = attrib;
      if (elementAttribs[name]) {
        elementAttribs[replaceName] = elementAttribs[name];
        delete elementAttribs[name];
      }
    });
  }
}

const c = cwd();
async function getWrapperComponent(option) {
  if (option === true)
    option = `${c}/**/*.{jsx,tsx}`;
  if (typeof option === "string") {
    const data = await getComponent(option);
    return data;
  } else if (Array.isArray(option)) {
    const allWrapperData = await Promise.all(option.map(getWrapperComponent));
    return allWrapperData.reduce((prev, next) => {
      return { ...prev, ...next };
    }, {});
  } else if (isObject(option)) {
    return option;
  } else {
    return {};
  }
}
async function getComponent(path2) {
  const component = await fg(path2, { ignore: [`${c}/node_modules`] });
  const data = {};
  component.forEach((item) => {
    let componentName = item.match(/\/([a-zA-Z0-9]+).[jt]sx/)?.[1];
    if (componentName) {
      componentName = handleComponentName(componentName);
      data[componentName] = item.replace(".[jt]sx", "");
    }
  });
  return data;
}
function handleComponentName(str) {
  if (/^[A-Z]/.test(str))
    return str;
  else if (/^[a-z]/.test(str))
    return initialUpperCase(str);
  else
    return str;
}
function initialUpperCase(str) {
  return str[0].toUpperCase() + str.slice(1);
}
function getComponentPath(markdownPath, componentPath) {
  if (!path.isAbsolute(componentPath))
    componentPath = path.resolve(c, componentPath);
  const relPath = path.relative(path.dirname(markdownPath), componentPath);
  const fixedPath = relPath.startsWith(".") ? relPath : `./${relPath}`;
  const finalPath = fixedPath.replace(/\\/g, "/");
  return finalPath;
}

function createMarkdown(useOptions) {
  const markdown = new MarkdownIt({ html: true, ...useOptions.markdownItOptions });
  markdown.disable("blockquote");
  useOptions.markdownItUses.forEach((e) => {
    const [plugin, options] = toArray(e);
    markdown.use(plugin, options);
  });
  useOptions.markdownItSetup(markdown);
  return async (raw, id) => {
    const { body, attributes } = frontMatter(raw);
    const attributesString = JSON.stringify(attributes);
    const wrapperComponentData = await getWrapperComponent(useOptions.wrapperComponent);
    const importComponentName = [];
    const html = markdown.render(body, { id });
    const root = parseDOM(html, { lowerCaseTags: false });
    root.forEach(markCodeAsPre);
    const h = DomUtils.getOuterHTML(root, { selfClosingTags: true }).replace(/"vfm{{/g, "{{").replace(/}}vfm"/g, "}}").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&amp;/g, "&").replace(/<!--/g, "{/*").replace(/-->/g, "*/}");
    let reactCode;
    let wrapperComponent = "";
    if (useOptions.wrapperComponentPath) {
      const componentPath = getComponentPath(id, useOptions.wrapperComponentPath);
      wrapperComponent = `import ${useOptions.wrapperComponentName} from '${componentPath}'
`;
      reactCode = `
        const markdown =
          <${useOptions.wrapperComponentName} 
            attributes={${attributesString}}
            importComponentName={${JSON.stringify(importComponentName)}}
          >
            <React.Fragment>
              ${h} 
            </React.Fragment> 
          </${useOptions.wrapperComponentName}>
      `;
    } else {
      reactCode = `
        const markdown =
          <div className='${useOptions.wrapperClasses}'>
            ${h}
          </div>
      `;
    }
    let importComponent = "";
    if (wrapperComponentData && typeof wrapperComponentData === "object" && importComponentName.length > 0) {
      importComponentName.forEach((componentName) => {
        const path = wrapperComponentData[componentName];
        if (path)
          importComponent += `import ${componentName} from '${getComponentPath(id, path)}'
`;
      });
    }
    const compiledReactCode = `
  function (props) {
    ${transformSync(reactCode, { ast: false, presets: ["@babel/preset-react"] }).code}
    return markdown
  } 
`;
    let code = `import React from 'react'
`;
    code += `${wrapperComponent}`;
    code += `${importComponent}`;
    code += `const ReactComponent = ${compiledReactCode}
`;
    code += `export default ReactComponent
`;
    code += `export const attributes = ${attributesString}`;
    return {
      code,
      map: { mappings: "" }
    };
    function markCodeAsPre(node) {
      if (node instanceof Element) {
        if (node.tagName.match(/^[A-Z].+/) && !importComponentName.includes(node.tagName))
          importComponentName.push(node.tagName);
        transformAttribs(node.attribs);
        if (node.tagName === "code") {
          const codeContent = DomUtils.getInnerHTML(node, { decodeEntities: true });
          node.attribs.dangerouslySetInnerHTML = `vfm{{ __html: \`${codeContent.replace(/([\\`])/g, "\\$1")}\`}}vfm`;
          node.childNodes = [];
        }
        if (node.childNodes.length > 0)
          node.childNodes.forEach(markCodeAsPre);
      }
      if (node instanceof Text) {
        if (node.type === "text") {
          node.data = node.data.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
      }
    }
  };
}

function VitePluginReactMarkdown(useOptions = {}) {
  const options = resolveOptions(useOptions);
  const markdownToReact = createMarkdown(options);
  const filter = createFilter(
    useOptions.include || /\.md$/,
    useOptions.exclude
  );
  return {
    name: "vite-plugin-react-markdown",
    enforce: "pre",
    async transform(raw, id) {
      if (!filter(id))
        return;
      try {
        return await markdownToReact(raw, id);
      } catch (e) {
        this.error(e);
      }
    }
  };
}

export { VitePluginReactMarkdown as default };
